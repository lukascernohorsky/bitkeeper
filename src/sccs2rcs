#!/usr/bin/env tclsh
# Copyright 1998,2015-2016 BitMover, Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Command-line flags modeled after the Perl original (-v verbose, -d debug, -n no-op)
set v 0
set d 0
set n 0
set argvCopy {}
foreach arg $argv {
    if {$arg eq "-v"} {
        set v 1
    } elseif {$arg eq "-d"} {
        set d 1
    } elseif {$arg eq "-n"} {
        set n 1
    } else {
        lappend argvCopy $arg
    }
}
set argv $argvCopy

if {$v} {
    set s ""
    set q ""
} else {
    set s "-s"
    set q "-q"
}

# Locate co/ci commands, falling back to echo when absent.
set co "echo"
set ci "echo"
if {[file executable "/usr/bin/co"]} {
    set co "/usr/bin/co"
}
if {[file executable "/usr/bin/ci"]} {
    set ci "/usr/bin/ci"
}
if {[file executable "/usr/sbin/co"]} {
    set co "/usr/sbin/co"
}
if {[file executable "/usr/sbin/ci"]} {
    set ci "/usr/sbin/ci"
}

# Pipe commands through /bin/sh just like the Perl script.
set sh [open "|sh" "w"]
chan configure $sh -buffering line

proc sh {line} {
    global d n sh
    if {$d || $n} {
        puts stderr $line
    }
    if {!$n} {
        puts $sh $line
    }
}

proc gfile {file} {
    return [string map {"SCCS/s." ""} $file]
}

proc basename {path} {
    return [file tail $path]
}

proc lrev {listValue} {
    set out {}
    foreach item $listValue {
        set out [linsert $out 0 $item]
    }
    return $out
}

proc processFile {file} {
    global s q co ci
    if {[catch {set sidsRaw [exec sids -p $file]} err]} {
        puts stderr $err
        return
    }
    set lines [split [string trimright $sidsRaw] "\n"]
    set sids [lrev $lines]
    if {[llength $sids]} {
        set sids [lreplace $sids end end]
    }
    set deltas [expr {[llength $sids] / 2}]
    sh "echo ==== $file $deltas revisions ===="

    set branches {}
    set gfile [gfile $file]
    set base [basename $gfile]

    sh "echo $file gets"
    for {set i 0} {$i < [llength $sids]} {incr i 2} {
        set rev [lindex $sids $i]
        sh "get $s -k -p -r$rev $file > $rev"
    }

    sh "echo $file ci"
    for {set i 0} {$i < [llength $sids]} {incr i 2} {
        set rev [lindex $sids $i]
        set parent [lindex $sids [expr {$i + 1}]]
        if {[regexp {\d+\.\d+\.\d} $rev]} {
            lappend branches $rev $parent
            continue
        }
        sh "mv $rev $base"
        sh "$ci -f $q -mfoo -l$rev $base < /dev/null"
    }

    sh "rcs -u $q $base\n/bin/rm $base"

    for {set i 0} {$i < [llength $branches]} {incr i 2} {
        set rev [lindex $branches $i]
        set parent [lindex $branches [expr {$i + 1}]]
        sh "$co -l $q -r$parent $base"
        sh "mv $rev $base"
        sh "$ci -f $q -mfoo -l$rev $base < /dev/null"
    }

    if {[llength $branches]} {
        sh "rcs -u $q $base"
    }
}

sh "mkdir RCS"

set inputs {}
if {[llength $argv]} {
    set inputs $argv
} else {
    while {[gets stdin line] >= 0} {
        lappend inputs $line
    }
}

foreach file $inputs {
    set file [string trim $file]
    if {$file eq ""} {
        continue
    }
    if {![string match "*SCCS/s.*" $file]} {
        puts stderr "Bad filename: $file, skipping it."
        continue
    }
    if {![file readable $file]} {
        puts stderr "Not readable: $file, skipping it."
        continue
    }
    processFile $file
}

close $sh
exit 0
